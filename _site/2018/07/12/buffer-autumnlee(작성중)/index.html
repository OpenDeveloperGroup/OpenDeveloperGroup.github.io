<!DOCTYPE html>
<html lang="ko">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Channel Buffer</title>
  <meta name="description" content="Channel Buffer Buffer 란? 사전적 의미는 완충을 말한다. 컴퓨터 시스템의 어떤 장치에서 다른 장치로 전송을 할 때에, 일시적으로 그 데이터를 보관하는 일종의 메모리 영역이다. buffering이라 함은 buffer를 채우는 동작을 일컷는 말로서 유사어로 Queue가 있다. 출처: http://lucrative.tistory.com/83 [Lucrative] Java 의 ByteBuffer java.nio 에서 제공되는 class fields capacity : Buffer 에 저장할 수 있는 최대크기 position : Buffer 를 읽고(쓰고) 있는 현재 위치. 초기값은 0 이며 읽고 쓸때마다 증가된다. limit 와 capacity 를 넘을 수 없다. limit : 읽고 쓸수있는 공간의 최대값. 변경이 가능하지만 capacity 보다 크게 지정될 수는 없다. flip 메소드 flip() makes a buffer ready for a new sequence of channel-write or relative get operations: It sets the limit to the current position and then sets the position to zero. limit 를 현재 position 으로 두고, position 은 0 으로 변경함. public final Buffer flip() { limit = position; position = 0; mark = -1; return this; } * &amp;lt;p&amp;gt; After a sequence of channel-read or &amp;lt;i&amp;gt;put&amp;lt;/i&amp;gt; operations, invoke * this method to prepare for a sequence of channel-write or relative * &amp;lt;i&amp;gt;get&amp;lt;/i&amp;gt; operations. For example: * * &amp;lt;blockquote&amp;gt;&amp;lt;pre&amp;gt; * buf.put(magic); // Prepend header * in.read(buf); // Read data into rest of buffer * buf.flip(); // Flip buffer * out.write(buf); // Write header + data to channel&amp;lt;/pre&amp;gt;&amp;lt;/blockquote&amp;gt; * buffer 에 값을 쓴 뒤, 쓴 값을 읽기 위해 position 을 옮겨주어야 한다. 읽기/쓰기를 flip(뒤집다) 한다는 의미로 받아들이면 된다. flip에 대한 일침 ByteBuffer is ill designed. There are lots of complaints from decent programmers. So don’t try to reason about it, just study and use the API carefully. Netty 의 ByteBuffer public abstract class AbstractByteBuf extends ByteBuf { private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractByteBuf.class); private static final String PROP_MODE = &quot;io.netty.buffer.bytebuf.checkAccessible&quot;; private static final boolean checkAccessible = SystemPropertyUtil.getBoolean(&quot;io.netty.buffer.bytebuf.checkAccessible&quot;, true); static final ResourceLeakDetector&amp;lt;ByteBuf&amp;gt; leakDetector; int readerIndex; int writerIndex; private int markedReaderIndex; private int markedWriterIndex; private int maxCapacity; ... public ByteBuf writeInt(int value) { this.ensureWritable0(4); this._setInt(this.writerIndex, value); this.writerIndex += 4; return this; } final void ensureWritable0(int minWritableBytes) { this.ensureAccessible(); if (minWritableBytes &amp;gt; this.writableBytes()) { if (minWritableBytes &amp;gt; this.maxCapacity - this.writerIndex) { throw new IndexOutOfBoundsException(String.format(&quot;writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s&quot;, this.writerIndex, minWritableBytes, this.maxCapacity, this)); } else { int newCapacity = this.alloc().calculateNewCapacity(this.writerIndex + minWritableBytes, this.maxCapacity); this.capacity(newCapacity); } } } } 궁금한점 1. buffer 가 사용하는 메모리는 제한되어 있는데, index 를 어떻게 관리할까? 2. netty 의 buffer pool">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/2018/07/12/buffer-autumnlee(%EC%9E%91%EC%84%B1%EC%A4%91)/">
  
  
  <link rel="alternate" type="application/rss+xml" title="ODG" href="http://localhost:4000/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Channel Buffer">
  <meta name="twitter:description" content="Channel Buffer Buffer 란? 사전적 의미는 완충을 말한다. 컴퓨터 시스템의 어떤 장치에서 다른 장치로 전송을 할 때에, 일시적으로 그 데이터를 보관하는 일종의 메모리 영역이다. buffering이라 함은 buffer를 채우는 동작을 일컷는 말로서 유사어로 Queue가 있다. 출처: http://lucrative.tistory.com/8...">
  
  

  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css?family=Bitter:400,400i,700" rel="stylesheet">

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">ODG</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/categories/">Categories</a>
      
        
        <a class="page-link" href="/tags/">Tags</a>
      
        
        <a class="page-link" href="https://github.com/OpenDeveloperGroup/OpenDeveloperGroup.github.io">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Channel Buffer</h1>
    
    <p class="post-meta"><time datetime="2018-07-12T00:00:00+00:00" itemprop="datePublished">Jul 12, 2018</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">autumnlee</span></span> •
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/categories/autumn/">Autumn</a>
      
    
  


 •
  
    
    
      
    
      
        <a href="/tags/netty/">Netty</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
        <a href="/tags/nio/">NIO</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
    
      
        <a href="/tags/buffer/">Buffer</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h1>Channel Buffer</h1>

<h3>Buffer 란?</h3>
<p>사전적 의미는 완충을 말한다.
컴퓨터 시스템의 어떤 장치에서 다른 장치로 전송을 할 때에, 
일시적으로 그 데이터를 보관하는 일종의 메모리 영역이다.
buffering이라 함은 buffer를 채우는 동작을 일컷는 말로서 유사어로 Queue가 있다.</p>

<p>출처: http://lucrative.tistory.com/83 [Lucrative]</p>

<h3>Java 의 ByteBuffer</h3>
<ul>
  <li>java.nio 에서 제공되는 class</li>
  <li>fields
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>capacity : Buffer 에 저장할 수 있는 최대크기
position : Buffer 를 읽고(쓰고) 있는 현재 위치. 초기값은 0 이며 읽고 쓸때마다 증가된다. limit 와 capacity 를 넘을 수 없다.
limit : 읽고 쓸수있는 공간의 최대값. 변경이 가능하지만 capacity 보다 크게 지정될 수는 없다.
</code></pre></div>    </div>
  </li>
  <li>flip 메소드</li>
</ul>

<blockquote>
  <p>flip() makes a buffer ready for a new sequence of channel-write or relative get operations: It sets the limit to the current position and then sets the position to zero.
limit 를 현재 position 으로 두고, position 은 0 으로 변경함.</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">final</span> <span class="n">Buffer</span> <span class="nf">flip</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">limit</span> <span class="o">=</span> <span class="n">position</span><span class="o">;</span>
    <span class="n">position</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">mark</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     * &lt;p&gt; After a sequence of channel-read or &lt;i&gt;put&lt;/i&gt; operations, invoke
     * this method to prepare for a sequence of channel-write or relative
     * &lt;i&gt;get&lt;/i&gt; operations.  For example:
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     * buf.put(magic);    // Prepend header
     * in.read(buf);      // Read data into rest of buffer
     * buf.flip();        // Flip buffer
     * out.write(buf);    // Write header + data to channel&lt;/pre&gt;&lt;/blockquote&gt;
     *
</code></pre></div></div>
<ul>
  <li>buffer 에 값을 쓴 뒤, 쓴 값을 읽기 위해 position 을 옮겨주어야 한다.</li>
  <li>읽기/쓰기를 flip(뒤집다) 한다는 의미로 받아들이면 된다.</li>
</ul>

<p><a href="https://stackoverflow.com/questions/14792968/what-is-the-purpose-of-bytebuffers-flip-method-and-why-is-it-called-flip">flip에 대한 일침</a></p>
<blockquote>
  <p>ByteBuffer is ill designed. There are lots of complaints from decent programmers.
So don’t try to reason about it, just study and use the API carefully.</p>
</blockquote>

<h3>Netty 의 ByteBuffer</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractByteBuf</span> <span class="kd">extends</span> <span class="n">ByteBuf</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">InternalLogger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">InternalLoggerFactory</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">AbstractByteBuf</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">PROP_MODE</span> <span class="o">=</span> <span class="s">"io.netty.buffer.bytebuf.checkAccessible"</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">checkAccessible</span> <span class="o">=</span> <span class="n">SystemPropertyUtil</span><span class="o">.</span><span class="na">getBoolean</span><span class="o">(</span><span class="s">"io.netty.buffer.bytebuf.checkAccessible"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="kd">static</span> <span class="kd">final</span> <span class="n">ResourceLeakDetector</span><span class="o">&lt;</span><span class="n">ByteBuf</span><span class="o">&gt;</span> <span class="n">leakDetector</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">readerIndex</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">writerIndex</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">markedReaderIndex</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">markedWriterIndex</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">maxCapacity</span><span class="o">;</span>

        <span class="o">...</span>

        <span class="kd">public</span> <span class="n">ByteBuf</span> <span class="nf">writeInt</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">ensureWritable0</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">_setInt</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">writerIndex</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">writerIndex</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">;</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">final</span> <span class="kt">void</span> <span class="nf">ensureWritable0</span><span class="o">(</span><span class="kt">int</span> <span class="n">minWritableBytes</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">ensureAccessible</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">minWritableBytes</span> <span class="o">&gt;</span> <span class="k">this</span><span class="o">.</span><span class="na">writableBytes</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">minWritableBytes</span> <span class="o">&gt;</span> <span class="k">this</span><span class="o">.</span><span class="na">maxCapacity</span> <span class="o">-</span> <span class="k">this</span><span class="o">.</span><span class="na">writerIndex</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IndexOutOfBoundsException</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s"</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">writerIndex</span><span class="o">,</span> <span class="n">minWritableBytes</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">maxCapacity</span><span class="o">,</span> <span class="k">this</span><span class="o">));</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">newCapacity</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">alloc</span><span class="o">().</span><span class="na">calculateNewCapacity</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">writerIndex</span> <span class="o">+</span> <span class="n">minWritableBytes</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">maxCapacity</span><span class="o">);</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">capacity</span><span class="o">(</span><span class="n">newCapacity</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>궁금한점
1. buffer 가 사용하는 메모리는 제한되어 있는데, index 를 어떻게 관리할까?
2. netty 의 buffer pool
</code></pre></div></div>


  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; ODG - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="http://localhost:4000/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
