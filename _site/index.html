<!DOCTYPE html>
<html lang="ko">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>ODG</title>
  <meta name="description" content="Open Developer Group">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/">
  
  
  <link rel="alternate" type="application/rss+xml" title="ODG" href="http://localhost:4000/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="ODG">
  <meta name="twitter:description" content="Open Developer Group">
  
  

  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css?family=Bitter:400,400i,700" rel="stylesheet">

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">ODG</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/categories/">Categories</a>
      
        
        <a class="page-link" href="/tags/">Tags</a>
      
        
        <a class="page-link" href="https://github.com/OpenDeveloperGroup/OpenDeveloperGroup.github.io">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            
              <a class="post-link" href="/2018/07/12/epoll-Sever-yjlee/">Epoll Server</a>
            
          </h1>

          <p class="post-meta">
            Jul 12, 2018
            
               •
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/categories/yjlee/">Yjlee</a>
      
    
      
    
      
    
      
    
  


 •
  
    
    
      
    
      
    
      
    
      
    
      
        <a href="/tags/select/">select</a>,
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/tags/epoll/">epoll</a>,
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
        <a href="/tags/netty/">Netty</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  


            
            
          </p>
        </header>

        <div class="post-content">
          <h1>select i/o 통지</h1>

<p>select 는 싱글 쓰레드로 다중 i/o를 처리하는 멀티플렉싱 통지 모델의 대표적인 방법이다.
  select는 많은 파일 디스크립터 들을 한꺼번에 관찰하는 FD_SET 구조체를 사용하여 빠르고 간편하게 유저에게
  파일 디스크립터의 상황을 알려준다.</p>

<p>FD_SET?
  FD_SET은 하나의 FD(파일 디스크립터)의 상태를 하나의 비트로 표현한다. 파일 디스크립터의 번호는 고유하기 때문에, 파일 디스크립터의 번호를 인덱스로하   여 해당 비트가 어떤 값을 가지고 있느냐에 따라서 준비상황을 통지 받을 수 있는 것이다. 먼저 파일 디스크립터의 번호를 FD_SET에 
  등록하면 해당 비트의 값  이 1로 저장된다</p>

<p>select는 read/ write/ error 3가지 I/O에 대한 통지를 받는다. 또한 select에 timeout을 설정하여 대기시간을 설정할 수 있다. 
  signature 는 다음과 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  int select( int maxfdNum, //파일 디스크립터의 관찰 범위 (0 ~ maxfdNum -1)
            fd_set *restrict readfds, //read I/O를 통지받을 FD_SET의 주소, 없으면 NULL
            fd_set *restrict writefds,//write I/O를 통지받을 FD_SET의 주소, 없으면 NULL
            fd_set *restrict errorfds,//error I/O를 통지받을 FD_SET의 주소, 없으면 NULL
            struct timeval *restrict timeout //null이면 변화가 있을 때까지 계속 Block, 
                                             //아니면 주어진 시간만큼 대기후 timeout.
           );  
</code></pre></div></div>

<p>## 샘플</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> struct timeval timeout; //타임 아웃에 사용할 timeval 변수 fd_set reads, cpy_reads; //read용 FD_SET과 그 사본을 저장할 변수 int fd_max = 0, fd_num = 0; //관찰 범위, 변경된 fd 개수 ... FD_ZERO(&amp;reads); //reads초기화 FD_SET(server_sock, &amp;reads); //server_socket 등록 max_fd = server_socket; //server_socket부터 관찰 범위에 추가 while(TRUE){ cpy_reads = reads; //FD_SET보존을 위한 복사 timeout.tv_sec = 5; //time out 값 설정 timeout.tv_usec = 5000; fd_num = select(fd_max + 1, &amp;cpy_reads, 0, 0, &amp;timeout); //FD_SET사본으로 select 호출 if(fd_num == -1) break; //에러 if(fd_num == 0) continue; //timeout for(int fd = 0; fd &lt; fd_max + 1 ; ++fd) { if(FD_ISSET(fd, &amp;cpy_reads)) //fd가 준비 완료 { if(i == server_socket) //fd가 서버인 경우  { //accpet 처리 (FD_SET으로 등록할 것) } else //fd가 클라이언트 세션인 경우 { //recv및 closesocket 처리 (FD_CLR로 삭제할 것) } } } close(server_socket); return 0;
</code></pre></div></div>

<p>## 한계
 select가 모든 fd를 순회하면서 recv()를 호출하는 방법보다는 훨씬 잘 구현된 멀티플렉싱인 것은 자명하다. 하지만 만들어진지 오래되다보니 그 한계점이 뚜렷하다. 동작 환경에 따라 다르지만 일반적으로 검사할 수 있는 fd개수가 최대 1024개로 제한된다. 그리고 관찰 영역에 포함되는 모든 파일 디스크립터에 대해서 순회하면서 한번씩 FD_ISSET으로 체크하는 것도 불필요한 체크인것 처럼 보인다. 실제로 상태가 변화된 fd의 목록을 넘겨준다면 더 빠르게 작동할 수 있지 않을까?</p>

<p>select를 사용해서 I/O의 상황을 알기 위해서는 프로세스가 커널에게 직접 상황 체크를 요청해야한다. 프로세스가 커널의 상황을 지속적으로 확인하고 그에 맞는 대응을 하는 형태로 구성되기 때문에 프로세스와 커널이 서로 동기화된 상태에서 정보를 주고 받는 형태로 볼 수 있다. 따라서 select의 통지형태를 동기형 통지방식이라 부를 수 있다.</p>

<h1>epoll</h1>
<p>epoll은 select의 단점을 보완하여 리눅스환경에서 사용할 수 있도록 만든 I/O 통지 기법이다. 전체 파일 디스크립터에 대한 반복문을 사용하지 않고, 커널에게 정보를 요청하는 함수(select 같은)를 호출할 때마다 전체 관찰 대상에 대한 정보를 넘기지도 않는다</p>

<p>계속해서 정보를 넘기지 않기 위해서 관찰 대상인 fd들의 정보를 담은 저장소를 직접 운영체제가 담당한다</p>

<p>운영체제에게 관찰대상의 저장소를 만들어달라고 요청하면 그 저장소에 해당하는 파일 디스크립터(이하 epoll_fd)를 리턴해준다. 관찰 영역이 변경되면(관찰대상 추가 삭제) epoll_fd를 통해 변경을 요청할 수 있다. 그리고 관찰 대상의 변경사항을 체크할때도 epoll_fd를 통해 확인을 한다. 따라서 전체 파일디스크립터를 순회하면서 FD_ISSET을 하는 문제는 더이상 발생하지 않는다.</p>

<p>## 샘플</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  int epoll_fd = epoll_create(EPOLL_SIZE); 
  struct epoll_event* events = malloc(sizeof(struct epoll_event)*EPOLL_SIZE); 
  struct epoll_event init_event; init_event.events = EPOLLIN; 
  init_event.data.fd = server_socket; 
  epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_socket, &amp;init_event); 
  while(TRUE) { 
    int event_count = epoll_wait(epoll_fd, events, EPOLL_SIZE, -1); 
    if( event_count = -1 ) break; for( int i = 0 ; i &lt; event_count; ++i ) 
    { if(events[i].data.fd == server_socket) //서버 소켓에 이벤트 
    { //accept 처리  ... init_event.events = EPOLLIN; 
    init_event.data.fd = new_client_socket; 
    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, new_client_socket, &amp;init_event); 
    } else //이벤트가 도착한 소켓들 
    { //read, write, closesocket처리 } } 
  } 
  closesocket(server_socket); close(epoll_fd); return 0;
</code></pre></div></div>

<p>## epoll 정리
epoll은 select의 단점을 많이 개선한 형태의 통지방식이다. FD_SET을 운영체제가 직접 관리하는 것으로 많은 부분이 개선되었다. 하지만 그 본질적인 동작 구조는 select와 크게 다르지 않다. 프로세스가 커널에게 지속적으로 I/O 상황을 체크하여 동기화 하는 개념은 여전히 유효하다. 따라서 epoll의 통지모델 역시 동기형 통지모델이다</p>

<h2>단점</h2>

<p>표준 지원사항이 아니라서 다른 유닉스에서는 사용할 수 없다</p>

<h1>정리</h1>

<h2>select</h2>
<p>특징으로는</p>
<ul>
  <li>등록된 file descriptor를 하나하나 체크를 해야하고 커널과 유저 공간 사이에 여러번의 데이터 복사가 있음.</li>
  <li>관리 file descriptor 수에 제한이 있음.</li>
  <li>사용 쉽고 지원 OS가 많아 이식성 좋음.</li>
</ul>

<p>file descriptor를 하나 하나에 체크하기 때문에 O(n)의 계산량이 필요합니다. 따라서 관리하는 file descriptor의 수가 증가하면 성능이 떨어진다. 
또한 관리 수가 한정되어 있기 때문에 그 수를 초과하면 사용할 수 없다.</p>

<h2>poll</h2>
<p>poll은 거의 select와 동일하지만 다음과 같은 차이가 있다.</p>
<ul>
  <li>관리 file descriptor 무제한.</li>
  <li>좀더 low level의 처리로 system call의 호출이 select보다 적음. 이식성 나쁨.</li>
  <li>접속수가 늘어나면 오히려 fd당 체크 마스크의 크기가 select는 3bit인데 비해, poll은 64bit정도이므로 양이 많아지면 성능이 select보다 떨어짐.</li>
</ul>

<h2>epoll</h2>
<p>linux커널 2.6.x이상 버전에만 지원되고 특징은 다음과 같다.</p>
<ul>
  <li>관리 fd의 수는 무제한.</li>
  <li>select, poll과 달리, fd의 상태가 kernel 에서 관리됨.</li>
  <li>일일이 fd 세트를 kernel 에 보낼 필요가 없음.</li>
  <li>kernel이 fd를 관리하고 있기 때문에 커널과 유저스페이스 간의 통신 오버헤드가 대폭 줄어듬.</li>
</ul>


        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            
              <a class="post-link" href="/2018/07/12/buffer-autumnlee(%EC%9E%91%EC%84%B1%EC%A4%91)/">Channel Buffer</a>
            
          </h1>

          <p class="post-meta">
            Jul 12, 2018
            
               •
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/categories/autumn/">Autumn</a>
      
    
  


 •
  
    
    
      
    
      
        <a href="/tags/netty/">Netty</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
        <a href="/tags/nio/">NIO</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
    
      
        <a href="/tags/buffer/">Buffer</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  


            
            
          </p>
        </header>

        <div class="post-content">
          <h1>Channel Buffer</h1>

<h3>Buffer 란?</h3>
<p>사전적 의미는 완충을 말한다.
컴퓨터 시스템의 어떤 장치에서 다른 장치로 전송을 할 때에, 
일시적으로 그 데이터를 보관하는 일종의 메모리 영역이다.
buffering이라 함은 buffer를 채우는 동작을 일컷는 말로서 유사어로 Queue가 있다.</p>

<p>출처: http://lucrative.tistory.com/83 [Lucrative]</p>

<h3>Java 의 ByteBuffer</h3>
<ul>
  <li>java.nio 에서 제공되는 class</li>
  <li>fields
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>capacity : Buffer 에 저장할 수 있는 최대크기
position : Buffer 를 읽고(쓰고) 있는 현재 위치. 초기값은 0 이며 읽고 쓸때마다 증가된다. limit 와 capacity 를 넘을 수 없다.
limit : 읽고 쓸수있는 공간의 최대값. 변경이 가능하지만 capacity 보다 크게 지정될 수는 없다.
</code></pre></div>    </div>
  </li>
  <li>flip 메소드</li>
</ul>

<blockquote>
  <p>flip() makes a buffer ready for a new sequence of channel-write or relative get operations: It sets the limit to the current position and then sets the position to zero.
limit 를 현재 position 으로 두고, position 은 0 으로 변경함.</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">final</span> <span class="n">Buffer</span> <span class="nf">flip</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">limit</span> <span class="o">=</span> <span class="n">position</span><span class="o">;</span>
    <span class="n">position</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">mark</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     * &lt;p&gt; After a sequence of channel-read or &lt;i&gt;put&lt;/i&gt; operations, invoke
     * this method to prepare for a sequence of channel-write or relative
     * &lt;i&gt;get&lt;/i&gt; operations.  For example:
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     * buf.put(magic);    // Prepend header
     * in.read(buf);      // Read data into rest of buffer
     * buf.flip();        // Flip buffer
     * out.write(buf);    // Write header + data to channel&lt;/pre&gt;&lt;/blockquote&gt;
     *
</code></pre></div></div>
<ul>
  <li>buffer 에 값을 쓴 뒤, 쓴 값을 읽기 위해 position 을 옮겨주어야 한다.</li>
  <li>읽기/쓰기를 flip(뒤집다) 한다는 의미로 받아들이면 된다.</li>
</ul>

<p><a href="https://stackoverflow.com/questions/14792968/what-is-the-purpose-of-bytebuffers-flip-method-and-why-is-it-called-flip">flip에 대한 일침</a></p>
<blockquote>
  <p>ByteBuffer is ill designed. There are lots of complaints from decent programmers.
So don’t try to reason about it, just study and use the API carefully.</p>
</blockquote>

<h3>Netty 의 ByteBuffer</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractByteBuf</span> <span class="kd">extends</span> <span class="n">ByteBuf</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">InternalLogger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">InternalLoggerFactory</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">AbstractByteBuf</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">PROP_MODE</span> <span class="o">=</span> <span class="s">"io.netty.buffer.bytebuf.checkAccessible"</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">checkAccessible</span> <span class="o">=</span> <span class="n">SystemPropertyUtil</span><span class="o">.</span><span class="na">getBoolean</span><span class="o">(</span><span class="s">"io.netty.buffer.bytebuf.checkAccessible"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="kd">static</span> <span class="kd">final</span> <span class="n">ResourceLeakDetector</span><span class="o">&lt;</span><span class="n">ByteBuf</span><span class="o">&gt;</span> <span class="n">leakDetector</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">readerIndex</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">writerIndex</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">markedReaderIndex</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">markedWriterIndex</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">maxCapacity</span><span class="o">;</span>

        <span class="o">...</span>

        <span class="kd">public</span> <span class="n">ByteBuf</span> <span class="nf">writeInt</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">ensureWritable0</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">_setInt</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">writerIndex</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">writerIndex</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">;</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">final</span> <span class="kt">void</span> <span class="nf">ensureWritable0</span><span class="o">(</span><span class="kt">int</span> <span class="n">minWritableBytes</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">ensureAccessible</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">minWritableBytes</span> <span class="o">&gt;</span> <span class="k">this</span><span class="o">.</span><span class="na">writableBytes</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">minWritableBytes</span> <span class="o">&gt;</span> <span class="k">this</span><span class="o">.</span><span class="na">maxCapacity</span> <span class="o">-</span> <span class="k">this</span><span class="o">.</span><span class="na">writerIndex</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IndexOutOfBoundsException</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s"</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">writerIndex</span><span class="o">,</span> <span class="n">minWritableBytes</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">maxCapacity</span><span class="o">,</span> <span class="k">this</span><span class="o">));</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">newCapacity</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">alloc</span><span class="o">().</span><span class="na">calculateNewCapacity</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">writerIndex</span> <span class="o">+</span> <span class="n">minWritableBytes</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">maxCapacity</span><span class="o">);</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">capacity</span><span class="o">(</span><span class="n">newCapacity</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>궁금한점
1. buffer 가 사용하는 메모리는 제한되어 있는데, index 를 어떻게 관리할까?
2. netty 의 buffer pool
</code></pre></div></div>


        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            
              <a class="post-link" href="/2018/07/10/%EB%AA%A8%EC%9E%84%EC%9D%BC%EC%A7%80/">20180710_모임일지</a>
            
          </h1>

          <p class="post-meta">
            Jul 10, 2018
            
               •
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/categories/%EB%AA%A8%EC%9E%84%EC%9D%BC%EC%A7%80/">모임일지</a>
      
    
      
    
  




            
            
          </p>
        </header>

        <div class="post-content">
          <p>Netty</p>

<ul>
  <li>
    <p>ChannelBuffer
 zero-copy</p>
  </li>
  <li>
    <p>기초
 select 함수</p>
  </li>
  <li>
    <p>다음 이시간까지</p>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>용진 : epoll 방식의 이해
환석 : zero-copy
대호 : interceptor chain filter / event model
가을 : flip (ChannelBuffer) 
</code></pre></div>    </div>
  </li>
</ul>

<p><a href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/buffer/package-summary.html#package_description">netty문서링크</a></p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            
              <a class="post-link" href="/2018/07/10/Architectural-Overview_Daeho/">Architectural Overview</a>
            
          </h1>

          <p class="post-meta">
            Jul 10, 2018
            
               •
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/categories/daeho/">Daeho</a>
      
    
      
    
      
    
  


 •
  
    
    
      
        <a href="/tags/architecture/">architecture</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
        <a href="/tags/netty/">Netty</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  


            
            
          </p>
        </header>

        <div class="post-content">
          <h1>Chapter 2. 아키텍쳐 개요</h1>
<p><img src="https://opendevelopergroup.github.io/assets/daeho/netty/architecture.png" alt="netty architecture" /></p>

<p>이번 챕터에서는, Netty에서 제공하는 core 기능을 알아보고 어떻게 그 기능들이 완벽한 네트워크 어플리케이션 개발에 도움을 주는지 설명할 것 입니다.</p>

<h2>2.1 풍부한 Buffer 자료구조</h2>
<p>Netty는 순차적인 byte를 표현하는데 <em>NIO ByteBuffer</em> 대신에 자신만의 buffer API를 사용합니다. 이것은 <em>ByteBuffer</em>를 사용하는 것 보다 확실한 이점을 가집니다.<br />
Netty의 새로운 buffer 타입인 <em>ChannelBuffer</em> 는 <em>ByteBuffer</em>의 문제를 해결하고 네트워크 어플리케이션 개발자의 요구사항을 충족시키기 위해 디자인 되었습니다. 아래에 몇몇 특징들이 나열되어있습니다.</p>

<blockquote>
  <p>필요하다면 자신만의 buffer를 정의할 수 있다.<br />
Transparent zero copy is achieved by a built-in composite buffer type.<br />
<em>StringBuffer</em>처럼 capacity가 요구에 따라 확장되는 동적인 buffer 타입이 제공된다<br />
flip()을 더 이상 call할 필요가 없다.<br />
ByteBuffer보다 더 빠르기도 하다.</p>
</blockquote>

<h2>2.2 범용 비동기 I/O API</h2>
<p>Java에서 제공하는 전통적인 I/O API에서 다른 타입과 메소드는 다른 전송 타입을 제공한다. 예를 들어, <em>java.net.Socket</em> 과 <em>java.net.DatagrmSocket</em>은 공통으로 상속하는 타입을 가지고 있지 않다. 그러므로 그들은 Socket I/O를 매우 다른 방향으로 수행한다.</p>

<p>이러한 불일치는 네트워크 어플리케이션이 한 전송을 다른 곳으로 포팅하는데 지루하고 어렵게 합니다. 
전송 간의 이동성 부족은 추가 전송이 필요할 경우 응용프로그램의 네트워크 layer를 재작성 해야하는 문제가 발생합니다.
이론적으로 많은 프로토콜은 TCP/IP, UDP/IP, SCTP 그리고 시리얼 포트 통신과 같은 하나 이상의 전송에서 실행할 수 있습니다.</p>

<p>설상가상으로, Java의 NIO API(New I/O API)는 OIO API(Old blocking I/O API)와 호환이 되지 않는다고 소개되었고 다음 릴리즈인 NIO.2(AIO)에서도 계속 그럴것이다.
이러한 API들은 서로 설계와 성능 특징들이 가지각색이기 때문에 구현 단계에 이르기도 전에 당신의 어플리케이션이 의존할 API를 결정해야 할때도 있다.</p>

<p>예를 들어, 만약 제공할 클라이언트 수가 매우 작고 NIO를 사용하는것 보다 OIO를 사용하는것이 훨씬 쉽기 때문에 OIO로 개발을 하고 싶어합니다.
그러나 당신의 비즈니스가 기하급수적으로 성장하고 서버가 수만개의 클라이언트를 동시적으로 지원해야하는 문제가 생길 수도 있습니다.
그렇다면 NIO로 개발하는것을 생각하게 됩니다. NIO Select API의 복잡성으로 인해 개발 시간이 너무 오래 걸릴 수도 있습니다.</p>

<p>Netty는 <em>Channel</em> 이라는 범용 비동기 I/O 인터페이스를 가지고 있습니다. 이것은 point-to-point 통신에 필요한 모든 명령을 추상화 한것입니다.
일단 당신의 어플리케이션이 하나의 Netty Transport 에서 작성된다면, 그 어플리케이션은 다른 Netty Tranport들에서도 동작할수있습니다.
Netty는 하나의 범용 API를 통해 여러 필수 전송들을 제공합니다.</p>

<blockquote>
  <p>NIO-based TCP/IP transport 
OIO_based TCP/IP transport<br />
OIO_based UDP/IP transport, and<br />
Local transport</p>
</blockquote>

<p>하나의 전송에서 다른것으로 전환하는데는 다른 <em>ChannelFactory</em> 구현체를 선택하는 것과 같이 몇줄 정도는 변경이 필요하다.</p>

<p>또한 직렬 포트 통신 전송과 같이 아직 작성되지 않은 새 전송을 활용할 수 있으며 몇 줄의 생성자 호출 만 교체 할 수도 있습니다. 
또한 핵심 API를 확장하여 자체 전송을 작성할 수 있습니다.</p>

<h2>2.3  인터셉터 체인 패턴을 기반으로한 이벤트 모델</h2>
<p>잘 정의되고 확장 가능한 이벤트 모델은 Event-Driven 어플리케이션의 필수 요소입니다. 
Netty는 I/O에 초점을 맞춘 잘 정의된 이벤트 모델을 가지고 있습니다. 
엄격한 계층에 의해 다른것과 구별된 각각의 이벤트 타입 때문에 당신이 기존의 코드를 손상시키지 않고 자신만의 이벤트 타입을 구현할수있도록 해줍니다. 
이것이 다른 프레임워크들과의 또 다들 차별점입니다.
많은 NIO 프레임워크들은 이벤트 모델의 개념이 거의 제한적이거나 없다. 당신이 커스텀 이벤트 타입을 추가하려고하면 그들은 기존 코드들을 손상시키게 된다.</p>

<p><em>ChannelEvent</em>는 <em>ChannelPipeLine안의 *ChannelHandler</em>들에 의해 처리됩니다.
파이프라인은 이벤트가 처리되고 파이프라인 내부의 핸들러들이 상호작용하는 방법들을 사용자가  컨트롤 할수 있도록 <em>Interception Filter</em> 패턴의 진보된 형태를 구현합니다.
예를 들어, socket에서 데이터를 읽어올때 무엇을 할지 정의 할 수 있습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class MyReadHandler implements SimpleChannelHandler {
    public void messageReceived(ChannelHandlerContext ctx, MessageEvent evt) {
        Object message = evt.getMessage();
        // Do something with the received message
        ...
        // And forward the event to the next handler.
        ctx.sendUpstream(evt);
    }
}
</code></pre></div></div>
<p>또한 핸들러가 write 요청을 받을때 수행할 것을 정의 할 수도 있습니다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class MyWriteHandler implements SimpleChannelHandler {
    public void writeRequested(ChannelHandlerContext ctx, MessageEvent evt) {
        Object message = evt.getMessage();
        // Do something with the message to be written.
        ...

        // And forward the event to the next handler.
        ctx.sendDownstream(evt);
    }
}
</code></pre></div></div>

<h2>2.4 빠른 개발을 위한 진보된 컴포넌트</h2>
<p>위에 언급 된 핵심 구성 요소 위에는 모든 유형의 네트워크 응용 프로그램 구현이 이미 가능하므로 Netty는 개발 페이지를 더욱 빠르게 할 수있는 일련의 고급 기능을 제공합니다.</p>

<h3>2.4.1 Codec framework</h3>
<p>Chapter 1.8에서 설명한 것처럼 프로토콜 코덱과 비즈니스 로직을 분리하는 것이 좋습니다. 그러나이 아이디어를 처음부터 구현할 때 몇 가지 문제가 있습니다. 메시지의 단편화를 처리해야합니다. 일부 프로토콜은 다층 (즉, 다른 하위 프로토콜의 상단에 구축 됨)입니다. 일부는 단일 상태 시스템에서 구현하기에는 너무 복잡합니다.</p>

<p>결과적으로 훌륭한 네트워크 응용 프로그램 프레임 워크는 유지 보수가 가능한 사용자 코덱을 생성하는 확장 가능하고, 재사용 가능하며, 단위 테스트 가능하고, 다중 계층화 된 코덱 프레임 워크를 제공해야합니다.</p>

<p>Netty는 간단하거나 아니거나, 바이너리 또는 텍스트인지 여부와 관계없이 프로토콜 코덱을 작성할 때 발생할 수있는 대부분의 문제를 해결할 수있는 다양한 기본 및 고급 코덱을 제공합니다.</p>

<h3>2.4.2 SSL / TLS Support</h3>
<p>OIO와 달리 NIO에서 SSL을 지원하는 것은 간단하지 않습니다. 데이터를 암호화하거나 해독하기 위해 단순히 스트림을 래핑 할 수는 없지만 javax.net.ssl.SSLEngine을 사용해야합니다. SSLEngine은 SSL만큼이나 복잡한 상태 시스템입니다. 암호 모음 및 암호화 키 협상 (또는 다시 협상), 인증서 교환 및 유효성 검사와 같은 모든 가능한 상태를 관리해야합니다. 게다가, SSLEngine은 완전히 스레드 안전하지는 않습니다.</p>

<p>Netty에서 <em>SslHandler</em>는 <em>SSLEngine</em>의 모든 세부적인 내용과 함정을 처리합니다.
<em>SslHandler</em>를 구성하여 <em>ChannelPipeline</em>에 삽입하기 만하면됩니다. 
또한 <em>StartTLS</em>와 같은 고급 기능을 매우 쉽게 구현할 수 있습니다.</p>

<h3>2.4.3 HTTP Implementation</h3>
<p>HTTP는 인터넷에서 가장 많이 사용되는 프로토콜입니다. Servlet 컨테이너와 같은 많은 HTTP 구현이 이미 있습니다. 그렇다면 Netty는 왜 핵심 부분에 HTTP를 가지고 있습니까?</p>

<p>Netty의 HTTP 지원은 기존 HTTP 라이브러리와 매우 다릅니다. 낮은 수준에서 HTTP 메시지를 교환하는 방법을 완벽하게 제어 할 수 있습니다. 기본적으로 HTTP 코덱과 HTTP 메시지 클래스가 결합되어 있으므로 강제 스레드 모델과 같은 제한이 없습니다. 즉, 원하는 방식으로 작동하는 고유 한 HTTP 클라이언트 또는 서버를 작성할 수 있습니다. 스레드 모델, 연결 수명주기 및 청크 분할 (chunked encoding)을 포함하여 HTTP 사양에있는 모든 것을 완벽하게 제어 할 수 있습니다.</p>

<blockquote>
  <p>매우 사용자 정의 할 수있는 특성 덕분에 다음과 같은 매우 효율적인 HTTP 서버를 작성할 수 있습니다.<br />
지속적인 연결과 서버 푸시 기술이 필요한 채팅 서버 (예 : Comet 및 WebSockets)<br />
전체 미디어가 스트리밍 될 때까지 연결을 유지해야하는 미디어 스트리밍 서버 (예 : 2 시간 분량의 비디오)
메모리 부족없이 큰 파일을 업로드 할 수있는 파일 서버 (예 : 요청 당 1GB 업로드)<br />
수만 개의 타사 웹 서비스에 비동기 적으로 연결되는 확장 가능한 매시업 클라이언트</p>
</blockquote>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            
              <a class="post-link" href="/2018/07/10/Architectural-Overview-yjlee/">Architectural Overview</a>
            
          </h1>

          <p class="post-meta">
            Jul 10, 2018
            
               •
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/categories/yjlee/">Yjlee</a>
      
    
      
    
      
    
      
    
  


 •
  
    
    
      
        <a href="/tags/architecture/">architecture</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
        <a href="/tags/netty/">Netty</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  


            
            
          </p>
        </header>

        <div class="post-content">
          <h1>Netty Architectural Overview</h1>

<h2>2.1 Rich Buffer Data Structure</h2>

<p>1) ByteBuffer를 대신한 자체 ByteBuf를 사용한다. 특징은 다음과 같다.
      - 자체 butter type을 정의할수 있다.
      - 투명한 제로 카피는 내장형 복합 버퍼 유형에 의해 달성됩니다
      - 동적 버퍼 유형은 즉시 제공되며, 용량은 필요에 따라 확장되며 StringBuffer와 동일합니다
      - flip() 함수는 필요 없다.
      - 종종 ByteBuffer 보다 빠르다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   * ByteBuffer
   * flip() 함수
</code></pre></div></div>

<p>## 2.2 Universal Asynchronous I/O API
    1) 일반 적인 Socket 과 DatagramSocket은 Sokcet i/o가 매우 다르다.
    2) 통신 프로그램 개발의 어려움을 해결해 준다.</p>

<p>NIO , OIO</p>

<p>## 2.3 Event Model based on the Interceptor Chain Pattern
   Netty는 I / O에 초점을 맞춘 잘 정의 된 이벤트 모델을 가지고 있습니다. 또한 각 이벤트 유형이 엄격한 
   유형 계층 구조에 의해 다른 유형과 구별되기 때문에 기존 코드를 손상시키지 않고 자신의 이벤트 유형을 구현할 수 있습니다</p>

<p>ChannelEvent는, ChannelPipeline 내의 ChannelHandler의리스트에 의해 처리됩니다</p>

<ul>
  <li>이벤트 등록 및 추가</li>
  <li>이벤트 감지 및 모니터링 (스레드 )</li>
  <li>이벤트 실행 (스레드)</li>
</ul>

<p>## 2.4 Advanced Components for More Rapid Development
   빠르게 개발 가능하다.</p>

<p>### 2.4.1 Codec framework
   프로토콜 코덱과 비즈니스 논리를 분리하는 것이 항상 좋은 생각입니다. 그러나이 아이디어를 처음부터 구현할 때 몇 가지 문제가 있습니다. 메시지의 단편화를 처리해야합니다. 일부 프로토콜은 다층 (즉, 다른 하위 프로토콜의 상단에 구축 됨)입니다. 일부는 너무 복잡하여 단일 상태 시스템에서 구현할 수 없습니다.</p>

<p>### 2.4.2. SSL / TLS Support</p>

<p>### 2.4.3  HTTP Implementation
    HTTP는 인터넷에서 가장 많이 사용되는 프로토콜입니다. Servlet 컨테이너와 같은 많은 HTTP 구현이 이미 있습니다. 그렇다면 왜 Netty는 HTTP를 핵심 요소로 사용합니까?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Netty의 HTTP 지원은 기존 HTTP 라이브러리와 매우 다릅니다. 낮은 수준에서 HTTP 메시지를 교환하는 방법을 완벽하게 제어 할 수 있습니다.
사용자 정의가 가능한 특성 덕분에 다음과 같은 매우 효율적인 HTTP 서버를 작성할 수 있습니다
  
- 지속적인 연결과 서버 푸시 기술이 필요한 채팅 서버 (예 : Comet 및 WebSockets)
- 전체 미디어가 스트리밍 될 때까지 연결을 유지해야하는 미디어 스트리밍 서버 (예 : 2 시간 분량의 비디오)
- 메모리 부족없이 큰 파일을 업로드 할 수있는 파일 서버 (예 : 요청 당 1GB 업로드)
- 수만 개의 타사 웹 서비스에 비동기 적으로 연결되는 확장 가능한 매시업 클라이언트

### 2.4.4. Google Protocol Buffer Integration




*** 매우 궁금함
  
아래 코드에서 null을 리턴하면 수신받을 패킷이 부족하다고 생각하고
기다리는 로직 코드를 보고 
  
public class TimeDecoder extends FrameDecoder {

@Override
protected Object decode(
        ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer) {
        
    if (buffer.readableBytes() &lt; 4) {
        return null; 
    }
    
    return buffer.readBytes(4);
}   }
</code></pre></div></div>

<p># 정리
     1) java nio 서버 / 클라이언트 구현 ByteBuffer 이해
     2) Netty ByteBuf 와 zero copy  , 왜 flip함수가 필요 없어 졌을까?
     3) Netty 이벤트 모델에 대한 이해 ( select 함수 실행 위치)
     4) epoll 방식의 이해
     5) codec 종류 및 protobuf 사용 예제
     6) http server 개발 실습</p>


        </div>
        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/2/">&laquo; Older</a>
    

    
  </div>



</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; ODG - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="http://localhost:4000/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
